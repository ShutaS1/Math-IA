console.time("Time");const sleep=a=>new Promise(b=>setTimeout(b,a)),PieSet=[1,2,3,4,5,6,7,8,9,11,12,13,14,15,16,17,18,19,21,22,23,24,25,26,27,28,29,31,32,33,34,35,36,37];let Numtrial=0,result={success:0,pinhu:0,sannanko:0,suuanko:0,chiitoi:0,kokushi:0,other:0};const sample=require("./sample");function Getpi(){let Hand=new Array(38).fill(0),promise;function FindHead(){return new Promise((async function(resolve,reject){let org=[];for(let m=0;m<136;m++)org.push(m);for(let m=0;m<14;m++)Hand[PieSet[org.splice(Math.random()*(136-m)|0,1)%34]]++;let Head_Temp=[],Head=0,Pairs=[],Kokushi_Flag=!0,Head_id;if(Hand.forEach((val,ind)=>{val>=2&&Pairs.push(ind);const a=!!val;a^sample.kokushi[ind]&&(Kokushi_Flag=!1)}),!Pairs.length)return reject("No head");if(7===Pairs.length)return resolve(7);if(Kokushi_Flag)return resolve(13);for(let m=0;m<38;m++)if(1===Hand[m]||4===Hand[m]){const Loan_Flag=await FindLone(Hand,m);if(Loan_Flag)return reject("Failed: Lone tile")}for(let m=0;m<Pairs.length;m++){Head_id=Pairs[m];const Loan_Flag=await FindLone(Hand,Head_id);if(2===Hand[Head_id]){if(Loan_Flag){if(Head)return reject("Failed: Too many heads");Head=Head_id}Head||Head_Temp.push(Head_id)}else Loan_Flag||Head_Temp.push(Head_id)}if(Head){const Flag_4Blocks=await Findblock(Head);return Flag_4Blocks>=0?resolve(Flag_4Blocks):reject("Failed: No 4 block")}if(Head_Temp.length){for(let m=0;m<Head_Temp.length;m++){const Flag_4Blocks=await Findblock(Head_Temp[m]);if(Flag_4Blocks>=0)return resolve(Flag_4Blocks)}return reject("Failed: No 4 block")}async function Findblock(a){let Block_Count=0,Triplet_Count=0,TryHand=[].concat(Hand);TryHand[a]-=2;let Triplet_Temp=[];for(let m=0;m<38;m++)if(TryHand[m]>=3){const Loan_Flag=FindLone(TryHand,m);if(Loan_Flag){if(TryHand[m]-=3,Block_Count++,Triplet_Count++,4===Block_Count)return 4}else Triplet_Temp.push(m)}for(let m=0;m<2**Triplet_Temp.length;m++){let TryHand_Temp=[].concat(TryHand);for(let n=0;n<3;n++)m&2**n&&(TryHand_Temp[Triplet_Temp[n]]-=3,Block_Count++,Triplet_Count++);if(4===Block_Count)return 4;let Fail_Flag=!1;for(let n=0;n<30&&!Fail_Flag;n++)for(n%10>=8&&TryHand_Temp[n]&&(Fail_Flag=!0);n%10<8&&TryHand_Temp[n]&&!Fail_Flag;)if(TryHand_Temp[n+1]&&TryHand_Temp[n+2]){for(let o=0;o<3;o++)TryHand_Temp[n+o]--;if(Block_Count++,4===Block_Count)return Triplet_Count}else Fail_Flag=!0}return-1}reject("Failed: No head exist")}))}Promise.resolve().then(FindHead).then(async num=>{const Type=await convert(num);result.success++,result[Type]++,Numtrial++;let out="";Hand.forEach((a,ind)=>{ind%10==1&&(out+=" "),ind/10==1&&(out=`${out}\tNumtrial:${Numtrial}\n`),ind/10==2&&(out=`${out}\tSucceeded:${Type}\n`),ind/10==3&&(out=`${out}\n`),out+=a}),console.log(out+"\n"),progress()}).catch(e=>{Numtrial++,progress()})}let j=1e7;async function calc(){for(let m=0;m<j/1e4;m++){for(let n=0;n<1e4;n++)Getpi();for(;Numtrial<=1e4*(m+1)-1;)await sleep(1)}}function progress(){Numtrial%(j/10)==0&&(console.log(Numtrial/j*100+"% done"),Numtrial===j&&(console.log("Calculation Ended"),console.timeEnd("Time"),console.log(`   Numtrial:${Numtrial} \n    Sucess:${result.success} Pinhu:${result.pinhu} \n    Sannanko:${result.sannanko} Chiitoi:${result.chiitoi} \n    Kokushi:${result.kokushi} Other:${result.other}`)))}async function convert(a){switch(a){case 0:return"pinhu";case 1:case 2:return"other";case 3:return"sannanko";case 4:return"suuanko";case 7:return"chiitoi";case 13:return"kokushi";default:console.log("Error occured: unknown hand type")}}async function FindLone(Hand,m){const Tile_Under=!(m%10<=2)&&(Hand[m-1]&&Hand[m-2]),Tile_Mid=m%10!=1&&m%10!=9&&(Hand[m-1]&&Hand[m+1]),Tile_Upper=!(m%10>=8)&&(Hand[m+1]&&Hand[m+2]);return m>30||!(Tile_Under||Tile_Mid||Tile_Upper)}calc();